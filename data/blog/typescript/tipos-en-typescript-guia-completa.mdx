---
title: 'Tipos en typescript: Una Gu√≠a Completa'
date: '2025-04-25'
tags: ['typescript']
draft: false
summary: 'Aprende c√≥mo funcionan los tipos en TypeScript, mejora la seguridad de tu c√≥digo y aprovecha todo el poder del tipado est√°tico.'
authors: ['default']
---

![tipos en typescript](https://res.cloudinary.com/dq0pfesxe/image/upload/v1745246500/tsx_xxhxma.png)

## **¬øQu√© son los tipos en TypeScript?**

En TypeScript, los **tipos** son una forma de describir y restringir los valores que puede tener una variable, funci√≥n o propiedad en el c√≥digo.  
Su principal objetivo es **proporcionar seguridad y claridad**, ayudando a detectar errores en tiempo de compilaci√≥n antes de que el programa se ejecute.

Un tipo define **qu√© clase de dato** (como `string`, `number`, `boolean`, etc.) puede ser asignado o manipulado, permitiendo a los desarrolladores escribir c√≥digo **m√°s predecible, robusto y f√°cil de mantener**.

## üìö √çndice de Contenidos

- [Introducci√≥n](#introducci√≥n)
- [¬øQu√© son los Tipos en TypeScript?](#qu√©-son-los-tipos-en-typescript)
- [Diferencias con JavaScript](#diferencias-con-javascript)
- [Tipos B√°sicos](#tipos-b√°sicos)
- [Tipos Personalizados](#tipos-personalizados)
- [Tipos de Uni√≥n y Tipos de Intersecci√≥n](#tipos-de-uni√≥n-y-tipos-de-intersecci√≥n)
- [Tipos Literales](#tipos-literales)
- [Inferencia de Tipos](#inferencia-de-tipos)
- [Tipos Gen√©ricos](#tipos-gen√©ricos)
- [Utilidades Avanzadas de Tipos](#utilidades-avanzadas-de-tipos)
- [Buenas Pr√°cticas con Tipos en TypeScript](#buenas-pr√°cticas-con-tipos-en-typescript)
- [Conclusi√≥n](#conclusi√≥n)

---

## Tipado Din√°mico en JavaScript

**Explicaci√≥n:**

- En JavaScript no hay control de tipo en tiempo de compilaci√≥n.
- Puedes asignar cualquier tipo de dato a una variable y el programa no se quejar√° (aunque pueda causar errores en ejecuci√≥n).

  ![dinamico](https://res.cloudinary.com/dq0pfesxe/image/upload/v1745245362/estatico_oq0nr4.png)

## Tipado Est√°tico en TypeScript

**Explicaci√≥n:**

- TypeScript te obliga (o infiere) que `mensaje` debe ser un `string`.
- Si intentas asignar un `number`, TypeScript lanza un error **antes** de ejecutar el c√≥digo.
- Esto ayuda a prevenir bugs y errores raros en producci√≥n.
  ![estatico](https://res.cloudinary.com/dq0pfesxe/image/upload/v1745245362/dinamic_rihmp4.png)

---

## üß† Comparaci√≥n Visual R√°pida

| Caracter√≠stica               | JavaScript                 | TypeScript                   |
| ---------------------------- | -------------------------- | ---------------------------- |
| **Tipado**                   | Din√°mico                   | Est√°tico                     |
| **Chequeo de tipos**         | En tiempo de ejecuci√≥n     | En tiempo de compilaci√≥n     |
| **Cambio de tipo permitido** | S√≠                         | No (salvo casting expl√≠cito) |
| **Detecci√≥n de errores**     | Solo al correr el programa | Antes de correrlo            |

---

## Tipos Primitivos en TypeScript

En TypeScript, los **tipos primitivos** son los tipos de datos m√°s b√°sicos, que representan valores simples e inmutables. No son objetos y no tienen m√©todos propios (aunque JavaScript los puede envolver en objetos autom√°ticamente cuando es necesario).  
Estos tipos permiten describir con precisi√≥n qu√© tipo de dato esperamos, ayudando a prevenir errores.

---

### üìå Ejemplos y Descripci√≥n de cada Tipo

### 1. **string**

Representa texto o cadenas de caracteres.

```typescript
let saludo: string = 'Hola, TypeScript!'
```

- **Descripci√≥n:** Se utiliza para almacenar cualquier texto. Las cadenas se encierran en comillas simples, dobles o invertidas (backticks).

---

### 2. **number**

Representa tanto n√∫meros enteros como flotantes.

```typescript
let edad: number = 30
let precio: number = 99.99
```

- **Descripci√≥n:** TypeScript no distingue entre enteros y decimales: todos son del tipo `number`.

---

### 3. **boolean**

Representa un valor de verdad: `true` o `false`.

```typescript
let esActivo: boolean = true
let tienePermiso: boolean = false
```

- **Descripci√≥n:** Perfecto para condiciones l√≥gicas, flags o estados binarios.

---

### 4. **null** y **undefined**

Representan ausencia o falta de valor.

```typescript
let datoVacio: null = null
let datoIndefinido: undefined = undefined
```

- **Descripci√≥n:**
  - `null` representa **intencionalmente** la ausencia de un valor.
  - `undefined` indica que una variable ha sido declarada pero **a√∫n no se le asign√≥ un valor**.

---

### 5. **symbol**

Representa un valor √∫nico e inmutable, normalmente usado como identificadores √∫nicos para propiedades de objetos.

```typescript
let id: symbol = Symbol('id_unico')
```

- **Descripci√≥n:** Incluso si dos s√≠mbolos tienen la misma descripci√≥n, siempre ser√°n valores diferentes. √ötil para crear propiedades privadas o √∫nicas en objetos.

---

### 6. **bigint**

Permite trabajar con n√∫meros enteros extremadamente grandes, m√°s all√° del l√≠mite de `number`.

```typescript
let numeroGrande: bigint = 9007199254740991n
```

- **Descripci√≥n:**
  - Se usa para representar n√∫meros enteros que exceden `Number.MAX_SAFE_INTEGER`.
  - Se define agregando una `n` al final del n√∫mero.

¬°Claro! Siguiendo el mismo estilo que antes, aqu√≠ tienes una **descripci√≥n general**, **ejemplos de c√≥digo** y **explicaciones** para los **Tipos Especiales** en TypeScript:

---

## Tipos Especiales en TypeScript

Adem√°s de los tipos primitivos, TypeScript ofrece **tipos especiales** que permiten manejar situaciones m√°s avanzadas o espec√≠ficas.  
Estos tipos son esenciales para construir aplicaciones seguras, robustas y flexibles, manejando casos como ausencia de valor, valores desconocidos o imposibles.

---

### üìå Ejemplos y Descripci√≥n de cada Tipo Especial

### 1. **any**

Permite que una variable contenga cualquier tipo de valor, desactivando el chequeo de tipos.

```typescript
let datos: any = 5
datos = 'ahora es un string'
datos = true
```

- **Descripci√≥n:**
  - `any` es un "escape" del sistema de tipos.
  - √ötil en migraciones o cuando no se puede conocer el tipo por adelantado.
  - **‚ö†Ô∏è Precauci√≥n:** Usarlo excesivamente elimina la principal ventaja de TypeScript.

---

### 2. **unknown**

Similar a `any`, pero **m√°s seguro**: no puedes operar sobre un valor `unknown` sin antes comprobar su tipo.

```typescript
let valorDesconocido: unknown = 'texto'

if (typeof valorDesconocido === 'string') {
  console.log(valorDesconocido.toUpperCase())
}
```

- **Descripci√≥n:**
  - `unknown` obliga a realizar una verificaci√≥n de tipo antes de usar el valor.
  - Ideal cuando recibes datos de fuentes externas donde el tipo no es confiable.

---

### 3. **void**

Se utiliza para indicar que una funci√≥n **no devuelve ning√∫n valor**.

```typescript
function mostrarMensaje(): void {
  console.log('Este mensaje no retorna nada.')
}
```

- **Descripci√≥n:**
  - `void` generalmente se usa en funciones cuyo √∫nico prop√≥sito es realizar efectos secundarios (como mostrar en pantalla, registrar logs, etc.).
  - No se debe usar `return` con un valor en funciones que devuelven `void`.

---

### 4. **never**

Indica que una funci√≥n **nunca devuelve un valor** (porque lanza un error o entra en un bucle infinito).

```typescript
function errorFatal(mensaje: string): never {
  throw new Error(mensaje)
}
```

- **Descripci√≥n:**
  - `never` se usa cuando una funci√≥n **termina la ejecuci√≥n abruptamente** o **nunca finaliza**.
  - Ayuda al sistema de tipos a identificar flujos que son inalcanzables o peligrosos.

¬°Claro! Siguiendo el mismo estilo que estamos usando, aqu√≠ tienes la parte de **Tipos de Datos Estructurados**:

---

## Tipos de Datos Estructurados en TypeScript

En TypeScript, los **tipos de datos estructurados** permiten representar **colecciones** de valores o **estructuras de datos complejas** como arrays, tuplas y objetos.  
Son fundamentales para modelar datos del mundo real de forma precisa y segura.

---

### üìå Ejemplos y Descripci√≥n de cada Tipo

### 1. **Arrays**

Colecci√≥n ordenada de elementos del mismo tipo.

```typescript
let numeros: number[] = [1, 2, 3, 4, 5]

let nombres: Array<string> = ['Ana', 'Luis', 'Carlos']
```

- **Descripci√≥n:**
  - Puedes usar la notaci√≥n `tipo[]` o `Array<tipo>`.
  - TypeScript asegurar√° que todos los elementos del array sean del tipo especificado.
  - Si intentas agregar un tipo distinto, se generar√° un error.

---

### 2. **Tuplas**

Array de **longitud fija** donde cada posici√≥n puede tener un tipo diferente.

```typescript
let persona: [string, number] = ['Mar√≠a', 28]
```

- **Descripci√≥n:**
  - Cada posici√≥n tiene un tipo de dato espec√≠fico.
  - Se usa para representar conjuntos de valores donde el orden y el tipo importan (por ejemplo, un par nombre-edad).
  - TypeScript verifica tanto la cantidad de elementos como el tipo de cada uno.

---

### 3. **Objetos**

Estructuras que agrupan propiedades nombradas con tipos espec√≠ficos.

```typescript
let usuario: { nombre: string; edad: number; activo: boolean } = {
  nombre: 'Pedro',
  edad: 35,
  activo: true,
}
```

- **Descripci√≥n:**
  - Los objetos permiten modelar entidades m√°s complejas, definiendo el tipo de cada propiedad.
  - Puedes anidar objetos dentro de otros objetos, usar tipos opcionales (`?`) y combinarlo con interfaces o type aliases para mayor claridad.

## Tipos Personalizados en TypeScript

En TypeScript puedes crear **tus propios tipos** para hacer tu c√≥digo m√°s legible, mantenible y seguro. Para eso existen dos herramientas principales: **Type aliases** y **Interfaces**.

---

### üîπ Type Aliases (`type`)

Un **type alias** te permite darle un nombre a cualquier tipo, incluso a tipos complejos.

```typescript
// Crear un alias para un objeto
type Usuario = {
  nombre: string
  edad: number
  activo: boolean
}

const user1: Usuario = {
  nombre: 'Ana',
  edad: 30,
  activo: true,
}
```

- Puedes usar `type` para tipos primitivos, uniones, intersecciones, etc.
- Son muy flexibles.

---

### üîπ Interfaces (`interface`)

Una **interface** tambi√©n describe la forma de un objeto, pero tiene algunas capacidades extra como la **extensi√≥n** (herencia entre interfaces).

```typescript
interface Usuario {
  nombre: string
  edad: number
  activo: boolean
}

const user2: Usuario = {
  nombre: 'Carlos',
  edad: 25,
  activo: false,
}
```

- **Interfaces** son ideales cuando describes estructuras de objetos.
- Permiten ser extendidas:

```typescript
interface Empleado extends Usuario {
  salario: number
}
```

### üéØ ¬øCu√°ndo usar cada uno?

- Usa **`interface`** si est√°s **describiendo objetos o clases**, especialmente si vas a extenderlos despu√©s.
- Usa **`type`** cuando necesites **composiciones m√°s avanzadas** como uniones, intersecciones o tipos primitivos.

> **Tip pr√°ctico**: en proyectos grandes, muchos equipos prefieren `interface` para modelos de datos (DTOs, entidades), y `type` para combinaciones o transformaciones de tipos.

## üîó Tipos de Uni√≥n y Tipos de Intersecci√≥n en TypeScript

En TypeScript puedes crear tipos m√°s flexibles combinando otros tipos usando **uniones** (`|`) e **intersecciones** (`&`).  
Esto te da much√≠simo control sobre lo que puede o no puede ser una variable.

---

### üîπ Tipos de Uni√≥n (`|`)

Un **tipo de uni√≥n** indica que una variable puede ser **de uno u otro tipo**.

```typescript
let respuesta: string | number

respuesta = 'Correcto' // ‚úÖ
respuesta = 200 // ‚úÖ
respuesta = true // ‚ùå Error: 'boolean' no est√° permitido
```

**Uso t√≠pico**: cuando una funci√≥n o variable puede aceptar m√∫ltiples tipos.

```typescript
function imprimirId(id: string | number) {
  console.log('ID:', id)
}

imprimirId(123) // OK
imprimirId('abc-456') // OK
```

---

### üîπ Tipos de Intersecci√≥n (`&`)

Un **tipo de intersecci√≥n** combina varios tipos **en uno solo**. El nuevo tipo debe cumplir **todos** los tipos al mismo tiempo.

```typescript
type Persona = {
  nombre: string
}

type Empleado = {
  salario: number
}

type EmpleadoPersona = Persona & Empleado

const trabajador: EmpleadoPersona = {
  nombre: 'Luc√≠a',
  salario: 50000,
}
```

**Uso t√≠pico**: cuando quieres **fusionar caracter√≠sticas** de m√∫ltiples tipos.

---

### üöÄ Ejemplo pr√°ctico combinando ambos

```typescript
type Admin = {
  rol: 'admin'
  permisos: string[]
}

type Usuario = {
  rol: 'user'
}

type PersonaSistema = Admin | Usuario

function accederSistema(persona: PersonaSistema) {
  if (persona.rol === 'admin') {
    console.log('Permisos:', persona.permisos)
  } else {
    console.log('Acceso b√°sico.')
  }
}
```

Aqu√≠ usamos **uni√≥n** para decir: "esta persona puede ser un `Admin` o un `Usuario`" y dependiendo de qu√© sea, actuamos diferente.

¬°Perfecto! Aqu√≠ tienes el contenido completo para la secci√≥n **Tipos Literales** que pediste, organizado con **explicaci√≥n**, **ejemplo** y **descripci√≥n**:

---

## üéØ Tipos Literales en TypeScript

### üîπ ¬øQu√© son los Tipos Literales?

Los **tipos literales** en TypeScript permiten restringir una variable a un **conjunto exacto de valores posibles**.  
En lugar de permitir cualquier valor de un tipo general (`string`, `number`, etc.), defines **valores espec√≠ficos** que son v√°lidos.

Esto mejora la **seguridad**, el **autocompletado** y previene **errores** al codificar.

---

### üîπ Ejemplo de Tipos Literales

```typescript
// Definimos un tipo literal
type RolUsuario = 'admin' | 'user' | 'guest'

function asignarPermisos(rol: RolUsuario) {
  if (rol === 'admin') {
    console.log('Acceso total')
  } else if (rol === 'user') {
    console.log('Acceso limitado')
  } else {
    console.log('Acceso de solo lectura')
  }
}

// Uso correcto
asignarPermisos('admin') // OK
asignarPermisos('guest') // OK

// Uso incorrecto
asignarPermisos('superadmin') // ‚ùå Error: Argument of type '"superadmin"' is not assignable to type 'RolUsuario'.
```

---

### üîπ Descripci√≥n

- **Seguridad:** Solo puedes usar los valores definidos. TypeScript marcar√° como error cualquier valor inesperado.
- **Inteligencia de autocompletado:** Los editores de c√≥digo pueden sugerirte autom√°ticamente los valores permitidos.
- **Ideal para:** Roles de usuarios, estados de procesos, opciones limitadas, etc.

---

### üöÄ Beneficios principales de usar Tipos Literales

- **Prevenci√≥n de errores**: Evitas valores mal escritos o inv√°lidos.
- **Documentaci√≥n autom√°tica**: El c√≥digo es m√°s legible y expl√≠cito.
- **Control en tiempo de compilaci√≥n**: Detectas problemas antes de ejecutar.

---

## üß† Inferencia de Tipos

### üîπ ¬øC√≥mo TypeScript infiere tipos autom√°ticamente?

TypeScript tiene la capacidad de **deducir el tipo** de una variable o expresi√≥n **bas√°ndose en el valor que se le asigna inicialmente**, sin que sea necesario especificarlo expl√≠citamente.

Esto se conoce como **inferencia de tipos** y permite escribir c√≥digo m√°s limpio sin perder seguridad de tipos.

**Ejemplo sencillo:**

```typescript
let saludo = 'Hola mundo'
// TypeScript infiere que 'saludo' es de tipo 'string'

saludo = '¬°Hola de nuevo!' // ‚úÖ Correcto
saludo = 123 // ‚ùå Error: Type 'number' is not assignable to type 'string'
```

Tambi√©n infiere:

- Tipos de retorno de funciones
- Tipos de propiedades en objetos
- Tipos dentro de arrays, etc.

---

### üîπ Ventajas de la Inferencia de Tipos

| ‚úÖ Ventaja                        | üìù Descripci√≥n                                                                  |
| --------------------------------- | ------------------------------------------------------------------------------- |
| **C√≥digo m√°s limpio**             | Menos necesidad de escribir anotaciones expl√≠citas.                             |
| **Mayor productividad**           | Permite desarrollar m√°s r√°pido.                                                 |
| **Mejor experiencia en editores** | Facilita autocompletado y sugerencias inteligentes en herramientas como VSCode. |
| **Mantenimiento sencillo**        | Menos c√≥digo escrito = menos c√≥digo que mantener.                               |

---

### üîπ Desventajas de la Inferencia de Tipos

| ‚ö†Ô∏è Desventaja                  | üìù Descripci√≥n                                                                   |
| ------------------------------ | -------------------------------------------------------------------------------- |
| **Inferencias incorrectas**    | En casos complejos, TypeScript podr√≠a inferir un tipo demasiado general (`any`). |
| **P√©rdida de claridad**        | El tipo de una variable no siempre es evidente al leer solo el c√≥digo.           |
| **Problemas en APIs p√∫blicas** | En librer√≠as o APIs es mejor ser expl√≠cito para evitar malentendidos en el uso.  |

---

### üéØ Consejo pr√°ctico

- Deja que TypeScript infiera tipos **en variables locales** donde el valor es obvio.
- **Anota expl√≠citamente** tipos en:
  - Par√°metros de funciones
  - Retornos de funciones
  - Interfaces p√∫blicas
  - APIs expuestas a otros m√≥dulos

¬°Genial! Aqu√≠ te dejo el contenido completo para esas √∫ltimas secciones de tu gu√≠a, siguiendo tu estructura clara y profesional:

---

## üß© Tipos Gen√©ricos

### üîπ ¬øQu√© son los gen√©ricos?

Los **gen√©ricos** en TypeScript permiten crear componentes que **funcionan con m√∫ltiples tipos** en lugar de uno solo.  
Son como "variables de tipos" que se definen al momento de usar la funci√≥n, clase o tipo.

> **Idea principal:** "No s√© qu√© tipo usar√°s, pero lo sabr√© cuando llames a la funci√≥n o crees el objeto".

---

### üîπ Ejemplos simples

**Funci√≥n gen√©rica:**

```typescript
function identidad<T>(valor: T): T {
  return valor
}

const numero = identidad(42) // n√∫mero
const texto = identidad('hola mundo') // string
```

**Clase gen√©rica:**

```typescript
class Caja<T> {
  contenido: T
  constructor(valor: T) {
    this.contenido = valor
  }
}

const cajaDeZapatos = new Caja<string>('Nike')
```

**Tipo gen√©rico:**

```typescript
type Resultado<T> = {
  exito: boolean
  datos: T
}

const respuesta: Resultado<string> = {
  exito: true,
  datos: 'Todo OK',
}
```

---

## üõ†Ô∏è Utilidades Avanzadas de Tipos

### üîπ ¬øQu√© son los _Utility Types_?

Los **Utility Types** son tipos predefinidos en TypeScript que permiten **transformar y construir nuevos tipos** de manera sencilla, ahorrando c√≥digo y evitando repeticiones.

---

### üîπ Principales Utility Types

| Utility Type  | Descripci√≥n                                   | Ejemplo                                                       |
| ------------- | --------------------------------------------- | ------------------------------------------------------------- |
| `Partial<T>`  | Vuelve todas las propiedades opcionales.      | `Partial<Usuario>` ‚Äî `nombre?: string; edad?: number;`        |
| `Required<T>` | Vuelve todas las propiedades obligatorias.    | `Required<Usuario>` ‚Äî `nombre: string; edad: number;`         |
| `Readonly<T>` | Hace que todas las propiedades sean readonly. | `Readonly<Usuario>` ‚Äî no se pueden modificar las propiedades. |
| `Pick<T, K>`  | Elige solo algunas propiedades de un tipo.    | `Pick<Usuario, "nombre">` ‚Äî solo incluye `nombre`.            |
| `Omit<T, K>`  | Excluye propiedades de un tipo.               | `Omit<Usuario, "edad">` ‚Äî elimina `edad` del tipo.            |

---

### üîπ Ejemplos pr√°cticos

```typescript
interface Usuario {
  nombre: string
  edad: number
  activo: boolean
}

const usuarioParcial: Partial<Usuario> = { nombre: 'Ana' }
const usuarioCompleto: Required<Usuario> = { nombre: 'Luis', edad: 29, activo: true }
const usuarioSoloNombre: Pick<Usuario, 'nombre'> = { nombre: 'Carlos' }
const usuarioSinEdad: Omit<Usuario, 'edad'> = { nombre: 'Laura', activo: false }
const usuarioSoloLectura: Readonly<Usuario> = { nombre: 'Sof√≠a', edad: 22, activo: true }

// usuarioSoloLectura.nombre = "Cambio"; // ‚ùå Error: no se puede modificar
```

---

## üìè Buenas Pr√°cticas con Tipos en TypeScript

- **Prefiere tipos expl√≠citos** cuando sea importante para la claridad del c√≥digo (por ejemplo, en funciones p√∫blicas).
- **Evita `any`** salvo casos realmente necesarios donde no puedas determinar un tipo seguro.
- **Reutiliza tipos** utilizando `type`, `interface` o _utility types_ para evitar duplicaciones y facilitar el mantenimiento.
- **Nombra tipos y gen√©ricos de forma clara** para mejorar la legibilidad (`T`, `K`, `V`, o nombres m√°s descriptivos como `Usuario`, `Producto`, etc.).
